package logging

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"regexp"
	"strings"
	"sync"
	"testing"
	"time"
)

// testWriter is a simple thread-safe writer used to capture log output during tests.
// It implements io.Writer and provides methods to access and clear the captured content.
type testWriter struct {
	mu sync.Mutex     // Ensures thread safety for concurrent writes/reads
	b  bytes.Buffer // Internal buffer to store log output
}

// Write implements the io.Writer interface, capturing written bytes thread-safely.
func (tw *testWriter) Write(p []byte) (n int, err error) {
	tw.mu.Lock()
	defer tw.mu.Unlock()
	return tw.b.Write(p)
}

// String returns the captured output as a string, ensuring thread safety.
func (tw *testWriter) String() string {
	tw.mu.Lock()
	defer tw.mu.Unlock()
	return tw.b.String()
}

// Reset clears the captured output buffer, ensuring thread safety.
func (tw *testWriter) Reset() {
	tw.mu.Lock()
	defer tw.mu.Unlock()
	tw.b.Reset()
}

// stdPrefixRegex is a pre-compiled regular expression used to check for the standard
// log prefix format (date, time with microseconds) generated by the default flags.
// It includes a capture group for the timestamp itself.
var stdPrefixRegex = regexp.MustCompile(`^(\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}\.\d{6}) `)

// setupTestLogger redirects the global logger output to a new testWriter instance
// for the duration of a test and returns the writer for inspection.
// It automatically restores the original logger output and level using t.Cleanup.
func setupTestLogger(t *testing.T) *testWriter {
	t.Helper() // Marks this function as a test helper
	originalOutput := logger.Writer() // Save the logger's current output destination
	originalLevel := GetLevel()       // Save the current global log level

	writer := &testWriter{} // Create a new writer to capture logs for this test
	SetOutput(writer)       // Redirect the global logger to the test writer

	// Register a cleanup function to restore the original state after the test completes
	t.Cleanup(func() {
		SetOutput(originalOutput) // Restore the original output destination
		SetLevel(originalLevel)   // Restore the original log level
	})

	return writer // Return the test writer so the test can access captured logs
}

// TestParseLevel tests the conversion of log level strings (case-insensitive)
// to their corresponding integer level constants. It also verifies error handling
// for invalid level strings, which should default to Info level.
func TestParseLevel(t *testing.T) {
	testCases := []struct {
		levelStr string // Input level string
		wantLvl  int    // Expected integer level constant
		wantErr  bool   // Whether an error is expected
	}{
		{"none", None, false},
		{"error", Error, false},
		{"warn", Warning, false},
		{"warning", Warning, false},
		{"info", Info, false},
		{"debug", Debug, false},
		{"invalid", Info, true},
		{"", Info, true},
	}

	for _, tc := range testCases {
		// Run each case as a subtest
		t.Run(tc.levelStr, func(t *testing.T) {
			gotLvl, gotErr := ParseLevel(tc.levelStr) // Call the function under test

			// Assert the returned level constant
			if gotLvl != tc.wantLvl {
				t.Errorf("ParseLevel(%q) level = %d, want %d", tc.levelStr, gotLvl, tc.wantLvl)
			}
			// Assert the error presence
			if (gotErr != nil) != tc.wantErr {
				t.Errorf("ParseLevel(%q) error presence mismatch: got error = %v, wantErr %v", tc.levelStr, gotErr, tc.wantErr)
			}
		})
	}
}

// TestSetGetLevel tests the atomicity and clamping behavior of SetLevel and GetLevel.
// It ensures that levels set outside the valid range [None, Debug] are clamped correctly.
func TestSetGetLevel(t *testing.T) {
	writer := setupTestLogger(t)
	_ = writer // Use writer to avoid unused variable error

	testLevels := []struct {
		setLevel   int // Level value passed to SetLevel
		wantGetLvl int // Expected level returned by GetLevel after setting
	}{
		{None, None}, {Error, Error}, {Warning, Warning}, {Info, Info}, {Debug, Debug},
		{-1, None}, {-100, None}, {5, Debug}, {100, Debug},
	}

	for _, tc := range testLevels {
		name := fmt.Sprintf("SetLevel(%d)", tc.setLevel)
		t.Run(name, func(t *testing.T) {
			writer.Reset()
			SetLevel(tc.setLevel)
			gotLvl := GetLevel()
			if gotLvl != tc.wantGetLvl {
				t.Errorf("GetLevel() after SetLevel(%d) = %d, want %d", tc.setLevel, gotLvl, tc.wantGetLvl)
			}

			logOutput := writer.String()
			// Check for the core message part, ignoring the exact prefix structure
			expectedMsgContent := "Log level set to 4"

			if tc.wantGetLvl == Debug {
				// CORRECTED CHECK: Use strings.Contains instead of HasSuffix
				if !strings.Contains(logOutput, expectedMsgContent) {
					t.Errorf("SetLevel(%d) which resulted in Debug level did not log expected confirmation message content %q. Output: %q", tc.setLevel, expectedMsgContent, logOutput)
				}
			} else {
				if logOutput != "" {
					t.Errorf("SetLevel(%d) expected no log output, but got: %q", tc.setLevel, logOutput)
				}
			}
		})
	}
}

// TestSetupLogging tests the SetupLogging function, which configures the global
// log level based on an input string. It verifies that valid strings set the correct
// level and invalid strings default to Info level while logging a warning.
func TestSetupLogging(t *testing.T) {
	writer := setupTestLogger(t)

	testCases := []struct {
		name         string // Name of the test case
		levelStr     string // Input level string for SetupLogging
		wantFinalLvl int    // Expected global level after calling SetupLogging
		wantWarning  bool   // Whether a warning about invalid level should be logged
	}{
		{"valid info", "info", Info, false},
		{"valid debug upper", "DEBUG", Debug, false},
		{"valid none mixed case", "NoNe", None, false},
		{"invalid level", "verbose", Info, true},
		{"empty string", "", Info, true},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			writer.Reset()

			originalLevel := GetLevel()
			SetLevel(Debug) // Ensure Warning level is loggable for the test setup call

			SetupLogging(tc.levelStr)
			gotLvl := GetLevel()

			// Restore previous level if the test didn't intend to set Debug
			if gotLvl != Debug && GetLevel() != originalLevel {
				SetLevel(originalLevel)
			}

			if gotLvl != tc.wantFinalLvl {
				t.Errorf("GetLevel() after SetupLogging(%q) = %d, want %d", tc.levelStr, gotLvl, tc.wantFinalLvl)
			}

			logOutput := writer.String()
			expectedWarningPrefix := "[WARN] "
			expectedWarningMsgPart := "Invalid log level"

			if tc.wantWarning {
				logLines := strings.Split(strings.TrimSpace(logOutput), "\n")
				warningFound := false
				for _, line := range logLines {
					if stdPrefixRegex.MatchString(line) &&
						strings.HasPrefix(stdPrefixRegex.ReplaceAllString(line, ""), expectedWarningPrefix) &&
						strings.Contains(line, expectedWarningMsgPart) {
						warningFound = true
						break
					}
				}
				if !warningFound {
					t.Errorf("SetupLogging(%q) did not log expected warning (prefix %q, content %q). Output: %q", tc.levelStr, expectedWarningPrefix, expectedWarningMsgPart, logOutput)
				}
			} else {
				// Check if the output *contains* the warning prefix AND message part (more robust)
				if strings.Contains(logOutput, expectedWarningPrefix) && strings.Contains(logOutput, expectedWarningMsgPart) {
					t.Errorf("SetupLogging(%q) logged unexpected warning. Output: %q", tc.levelStr, logOutput)
				}
			}
		})
	}
}

// TestSetOutput tests the ability to change the logger's output destination dynamically.
func TestSetOutput(t *testing.T) {
	setupTestLogger(t)
	SetLevel(Debug)

	buf1 := &bytes.Buffer{}
	SetOutput(buf1)
	Logf(Info, "Message to buffer 1")
	output1 := buf1.String()
	if !strings.Contains(output1, "[INFO] Message to buffer 1") {
		t.Errorf("Log message not found in buffer 1. Got: %q", output1)
	}

	buf2 := &bytes.Buffer{}
	SetOutput(buf2)
	Logf(Info, "Message to buffer 2")
	output2 := buf2.String()
	if !strings.Contains(output2, "[INFO] Message to buffer 2") {
		t.Errorf("Log message not found in buffer 2. Got: %q", output2)
	}

	output1After := buf1.String()
	if output1 != output1After {
		t.Errorf("Buffer 1 received message meant for buffer 2. Buffer 1 content: %q", output1After)
	}

	SetOutput(io.Discard)
	Logf(Info, "Message to discard")
}

// TestLogfBehavior systematically tests that messages are logged only when their
// level is less than or equal to the currently set global log level.
func TestLogfBehavior(t *testing.T) {
	writer := setupTestLogger(t)

	levelsToSet := []struct {
		level int
		name  string
	}{
		{None, "None"}, {Error, "Error"}, {Warning, "Warning"}, {Info, "Info"}, {Debug, "Debug"},
	}

	messagesToLog := []struct {
		level int
		name  string
		msg   string
		args  []interface{}
	}{
		{Error, "ErrorLevelMessage", "Error message %d", []interface{}{1}},
		{Warning, "WarningLevelMessage", "Warning message %s", []interface{}{"warn"}},
		{Info, "InfoLevelMessage", "Info message", nil},
		{Debug, "DebugLevelMessage", "Debug message %v", []interface{}{true}},
	}

	// CORRECTED Regex: Made more general, less reliant on specific func name structure
	debugPrefixRegex := regexp.MustCompile(`logging_test\.go:\d+:[^ ]+ `)

	for _, setLvl := range levelsToSet {
		t.Run(fmt.Sprintf("LevelSetTo_%s", setLvl.name), func(t *testing.T) {
			SetLevel(setLvl.level)

			for _, logMsg := range messagesToLog {
				writer.Reset()
				Logf(logMsg.level, logMsg.msg, logMsg.args...)
				logOutput := writer.String()
				messageShouldBeLogged := logMsg.level <= setLvl.level

				if messageShouldBeLogged {
					if logOutput == "" {
						t.Errorf("Message level %d: Expected log message (when set level is %d), but output was empty", logMsg.level, setLvl.level)
						continue
					}
					if !stdPrefixRegex.MatchString(logOutput) {
						t.Errorf("Message level %d: Log output missing standard prefix. Got: %q", logMsg.level, logOutput)
					}

					var expectedLevelPrefixWithSpace string
					switch logMsg.level {
					case Error: expectedLevelPrefixWithSpace = "[ERROR] "
					case Warning: expectedLevelPrefixWithSpace = "[WARN] "
					case Info: expectedLevelPrefixWithSpace = "[INFO] "
					case Debug: expectedLevelPrefixWithSpace = "[DEBUG] "
					default: t.Fatalf("Unexpected logMsg.level: %d", logMsg.level)
					}

					contentAfterTimestamp := stdPrefixRegex.ReplaceAllString(logOutput, "")
					var contentToCheckForMessage string

					if logMsg.level == Debug {
						if !strings.HasPrefix(contentAfterTimestamp, expectedLevelPrefixWithSpace) {
							t.Errorf("Message level %d (Debug): Log output missing level prefix %q. Got content after timestamp: %q", logMsg.level, expectedLevelPrefixWithSpace, contentAfterTimestamp)
						}
						debugPart := strings.TrimPrefix(contentAfterTimestamp, expectedLevelPrefixWithSpace)
						if !debugPrefixRegex.MatchString(debugPart) {
							t.Errorf("Message level %d (Debug): Log output missing or incorrect caller info (file:line:func). Got content after prefixes: %q", logMsg.level, debugPart)
						}
						contentToCheckForMessage = debugPrefixRegex.ReplaceAllString(debugPart, "")
					} else {
						if !strings.HasPrefix(contentAfterTimestamp, expectedLevelPrefixWithSpace) {
							t.Errorf("Message level %d: Log output missing level prefix %q. Got content after timestamp: %q", logMsg.level, expectedLevelPrefixWithSpace, contentAfterTimestamp)
						}
						contentToCheckForMessage = strings.TrimPrefix(contentAfterTimestamp, expectedLevelPrefixWithSpace)
					}

					expectedContent := fmt.Sprintf(logMsg.msg, logMsg.args...)
					// CORRECTED Check: Ensure the remaining content *starts* with the message
					if !strings.HasPrefix(strings.TrimSpace(contentToCheckForMessage), expectedContent) {
						t.Errorf("Message level %d: Log output missing correct message content.\nExpected prefix: %q\nGot content after level/caller prefixes: %q", logMsg.level, expectedContent, contentToCheckForMessage)
					}

				} else {
					if logOutput != "" {
						t.Errorf("Message level %d: Expected no log message (when set level is %d), but got output: %q", logMsg.level, setLvl.level, logOutput)
					}
				}
			}
		})
	}
}

// TestLogfTimestamp verifies that consecutive log messages receive distinct timestamps.
func TestLogfTimestamp(t *testing.T) {
	writer := setupTestLogger(t)
	SetLevel(Info)

	writer.Reset()
	Logf(Info, "First message")
	output1 := writer.String()

	time.Sleep(2 * time.Millisecond)

	writer.Reset()
	Logf(Info, "Second message")
	output2 := writer.String()

	ts1Match := stdPrefixRegex.FindStringSubmatch(output1)
	ts2Match := stdPrefixRegex.FindStringSubmatch(output2)

	if len(ts1Match) < 2 || len(ts2Match) < 2 {
		t.Fatalf("Could not extract timestamps using capture group from log output.\nOutput 1: %q\nOutput 2: %q", output1, output2)
	}

	ts1 := ts1Match[1]
	ts2 := ts2Match[1]

	if ts1 == ts2 {
		t.Errorf("Timestamps for consecutive log messages are identical: %q", ts1)
	}
	if !strings.Contains(output1, "First message") {
		t.Errorf("First message content not found in output 1: %q", output1)
	}
	if !strings.Contains(output2, "Second message") {
		t.Errorf("Second message content not found in output 2: %q", output2)
	}
}

// TestLogConcurrency performs basic concurrent logging and level changes.
func TestLogConcurrency(t *testing.T) {
	writer := setupTestLogger(t)
	SetLevel(Debug)

	numGoroutines := 10
	numLogsPerG := 100
	var wg sync.WaitGroup
	wg.Add(numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func(gID int) {
			defer wg.Done()
			for j := 0; j < numLogsPerG; j++ {
				SetLevel((gID + j) % (Debug + 1))
				Logf(Info, "Log from goroutine %d, iter %d, current level %d", gID, j, GetLevel())
				Logf(Debug, "Debug log from goroutine %d, iter %d, current level %d", gID, j, GetLevel())
			}
		}(i)
	}

	wg.Wait()

	logOutput := writer.String()
	lines := strings.Split(strings.TrimSpace(logOutput), "\n")
	actualLines := 0
	if logOutput != "" {
		actualLines = len(lines)
	}

	if actualLines == 0 && numGoroutines > 0 && numLogsPerG > 0 {
		t.Logf("WARNING: Expected some log output from concurrent logging, but got none. (Possible if level was consistently None).")
	}

	if actualLines > 0 && !stdPrefixRegex.MatchString(lines[0]) {
		t.Errorf("Concurrent log output missing standard prefix. First line: %q", lines[0])
	}

	t.Logf("Concurrent logging produced %d lines (max possible ~%d)", actualLines, numGoroutines*numLogsPerG*2)
}

// TestDefaultLogger verifies that the logger writes to os.Stderr by default.
func TestDefaultLogger(t *testing.T) {
	originalOutput := logger.Writer()
	originalLevel := GetLevel()
	originalFlags := logger.Flags()
	t.Cleanup(func() {
		logger = log.New(originalOutput, "", originalFlags)
		SetLevel(originalLevel)
	})

	logger = log.New(os.Stderr, "", log.Ldate|log.Ltime|log.Lmicroseconds)
	SetLevel(Info)

	if logger.Writer() != os.Stderr {
		t.Errorf("Default logger writer is not os.Stderr, got: %T", logger.Writer())
	}
	expectedFlags := log.Ldate | log.Ltime | log.Lmicroseconds
	if logger.Flags() != expectedFlags {
		t.Errorf("Default logger flags = %d, want %d", logger.Flags(), expectedFlags)
	}
}
